#!/usr/bin/env ruby

# archive-meeting: Archive a meeting by combining transcripts and chat logs, generating an executive summary, and updating notes
#
# This script helps you archive a meeting by:
#   1. Ensuring required subfolders exist in your notes directory (Executive Summaries, Meeting Notes, Transcripts).
#   2. Prompting you to select a meeting folder (e.g., from a Zoom transcripts directory).
#   3. Finding transcript and chat log files in the selected folder.
#   4. Combining these files into a single transcript file, saved in a dated subfolder under Transcripts.
#   5. Generating an executive summary for the meeting using an LLM (via the `llm` command and a prompt file), saved in Executive Summaries.
#   6. Locating the latest Weekly Notes file and, with LLM+fzf, suggesting which Meeting Notes file (group/person/section) to update.
#   7. Updating or creating the appropriate Meeting Notes file with links to the new transcript and executive summary.
#
# Usage:
#   archive-meeting --transcripts-dir DIR --target-dir DIR --executive-summary-prompt-path PATH [--llm-model MODEL]
#
# Options:
#   --transcripts-dir DIR                Path to the folder containing meeting folders (e.g., Zoom transcripts)
#   --target-dir DIR                     Path to your notes directory (where subfolders like Meeting Notes, Transcripts, etc. live)
#   --executive-summary-prompt-path PATH Path to the LLM prompt file for generating executive summaries
#   --llm-model MODEL                    (Optional) Model alias to use for the llm command
#   -h, --help                           Show help message
#
# Requirements:
#   - Ruby
#   - The `llm` command-line tool (for LLM summarization)
#   - `fzf` (for interactive selection)
#   - A `select-folder` script in the same directory (for folder selection)
#
# Typical workflow:
#   1. Run the script with the required arguments.
#   2. Select the meeting folder when prompted.
#   3. The script combines transcripts, generates a summary, and helps you update the right notes file with links.
#
# Example:
#   archive-meeting \
#     --transcripts-dir ~/Documents/Zoom/ \
#     --target-dir ~/Notes/ \
#     --executive-summary-prompt-path ~/prompts/meeting-summary.txt

require "date"
require "fileutils"
require "open3"
require "optparse"
require "shellwords"

# === Utility Modules ===

# LlmUtils: Utility for LLM command-line flag handling
module LlmUtils
  # Returns the model flag for the llm command, or an empty string if no model is specified.
  #
  # llm_model - The String model name or nil.
  #
  # Returns a String suitable for the llm command.
  def self.llm_model_flag(llm_model)
    llm_model && !llm_model.strip.empty? ? "-m #{Shellwords.escape(llm_model)}" : ""
  end
end

# MeetingFileUtils: Utilities for meeting-related file and directory operations
#
# Provides helper methods for common file and directory tasks in the meeting workflow.
module MeetingFileUtils
  # Updates or creates a Meeting Notes file for a given group/person/section.
  #
  # meeting_notes_file - The String path to the Meeting Notes file.
  # meeting_date       - The String date (YYYY-MM-DD).
  # transcript_link    - The String wikilink to the transcript.
  # summary_link       - The String wikilink to the executive summary.
  # filename           - The String filename (without extension) for the note.
  #
  # If the file exists and a section for this date exists, appends the new links to that section.
  # Otherwise, prepends a new section for the date at the top.
  #
  # Returns nothing.
  def self.update_meeting_notes_file(meeting_notes_file:, meeting_date:, transcript_link:, summary_link:, filename:)
    date_section_header = "## #{meeting_date}"
    new_links = "- #{transcript_link}\n- #{summary_link}\n\n"
    if File.exist?(meeting_notes_file)
      content = File.read(meeting_notes_file)
      # Regex to find all date sections
      sections = content.split(/^(## \d{4}-\d{2}-\d{2})/)
      # sections[0] is preamble (likely empty), then alternating header, body, header, body...
      found = false
      new_content = sections.each_slice(2).map do |header, body|
        if header == date_section_header
          found = true
          # Append new links to the end of this date section's body
          header + (body || "") + new_links
        elsif header
          header + (body || "")
        else
          body || ""
        end
      end.join
      unless found
        # Prepend new section if not found
        new_section = "#{date_section_header}\n\n#{new_links}"
        new_content = new_section + new_content
      end
      File.write(meeting_notes_file, new_content)
      puts "Updated existing Meeting Notes file: #{meeting_notes_file}"
    else
      # Create new file with just this section
      new_section = "#{date_section_header}\n\n#{new_links}"
      File.write(meeting_notes_file, new_section)
      puts "Created new Meeting Notes file: #{meeting_notes_file}"
    end
  end

  # Writes a combined transcript and chat log file from a list of files.
  #
  # dest_file        - The String path to the output file to write.
  # transcript_files - An Array of String file paths to include in the output.
  #
  # Each file is wrapped with START/END markers using its basename.
  #
  # Returns nothing.
  def self.write_combined_transcript(dest_file:, transcript_files:)
    File.open(dest_file, "w") do |f|
      transcript_files.each do |file|
        File.open(file, "r") do |input|
          f.puts "===== START: #{File.basename(file)} ====="
          f.puts input.read
          f.puts "===== END: #{File.basename(file)} ====="
          f.puts
        end
      end
    end
  end

  # Ensures the required subfolders exist in the target directory.
  #
  # target_dir - The String path to the base notes directory.
  #
  # Returns nothing.
  def self.ensure_subfolders(target_dir:)
    [
      "Executive Summaries",
      "Meeting Notes",
      "Transcripts",
    ].each do |subdir|
      path = File.join(target_dir, subdir)
      FileUtils.mkdir_p(path) unless Dir.exist?(path)
    end
  end

  # Finds transcript and chat log files in a given folder.
  #
  # folder - The String path to the meeting folder.
  #
  # Returns an Array of String file paths.
  def self.find_transcript_files(folder:)
    Dir[File.join(folder, '*.{txt,vtt}')]
  end

  # Prepares and returns the output directory for transcripts for a given date.
  #
  # transcripts_base - The String base path for transcripts.
  # meeting_date     - The String date (YYYY-MM-DD).
  #
  # Returns the String path to the created directory.
  def self.prepare_transcript_dir(transcripts_base:, meeting_date:)
    dest_dir = File.join(transcripts_base, meeting_date)
    FileUtils.mkdir_p(dest_dir)
    dest_dir
  end

  # Finds the next available transcript filename in a directory.
  #
  # dest_dir - The String path to the transcript directory.
  #
  # Returns the next available filename as a String (e.g., "01.md").
  def self.next_transcript_filename(dest_dir:)
    existing = Dir[File.join(dest_dir, '[0-9][0-9].md')].map { |f| File.basename(f, '.md').to_i }
    next_num = (existing.max || 0) + 1
    format('%02d.md', next_num)
  end
end

# LlmWorkflowUtils: Workflow helpers for LLM-based operations
#
# Provides higher-level methods for running LLM commands and handling their output.
module LlmWorkflowUtils
  # Uses LLM and fzf to select a Meeting Notes group/person/section.
  #
  # weekly_notes_content        - The String content of the latest Weekly Notes file.
  # executive_summary_content   - The String content of the executive summary.
  # llm_model                   - The String model name or nil.
  #
  # Returns the String selection made by the user (group/person/section name).
  def self.select_meeting_notes_section(weekly_notes_content:, executive_summary_content:, llm_model:)
    llm_instructions = <<~PROMPT
      Given the following weekly notes and executive summary, suggest the most likely group/person or section in the Meeting Notes folder to update for this meeting. List only the group/person/section names, one per line, most likely first. Do not include any extra commentary or explanation.

      WEEKLY NOTES:
      #{weekly_notes_content}

      EXECUTIVE SUMMARY:
      #{executive_summary_content}

      Focus only on the "## Schedule" section of the Weekly Notes.
    PROMPT

    llm_model_flag = LlmUtils.llm_model_flag(llm_model)
    llm_cmd = "llm #{llm_model_flag}"
    fzf_cmd = "fzf --prompt='Select Meeting Notes group/person: '"
    puts "Suggesting Meeting Notes section with LLM and fzf..."
    selection = nil
    Open3.popen3(llm_cmd) do |stdin, stdout, stderr, wait_thr|
      stdin.puts llm_instructions
      stdin.close
      llm_output = stdout.read
      IO.popen(fzf_cmd, "r+") do |fzf|
        fzf.puts llm_output
        fzf.close_write
        selection = fzf.read.strip
      end
    end
    puts "You selected: #{selection}"
    selection
  end

  # Generates an executive summary using an LLM and saves it to a file.
  #
  # dest_file   - The String path to the transcript file to summarize.
  # summary_file - The String path to write the summary output.
  # llm_model   - The String model name or nil.
  # prompt_path - The String path to the LLM prompt file.
  #
  # Returns nothing.
  def self.generate_executive_summary(dest_file:, summary_file:, llm_model:, prompt_path:)
    llm_model_flag = LlmUtils.llm_model_flag(llm_model)
    llm_cmd = "cat #{Shellwords.escape(dest_file)} | llm #{llm_model_flag} -f #{Shellwords.escape(prompt_path)}"
    puts "Generating executive summary with llm..."
    summary = `#{llm_cmd}`
    File.write(summary_file, summary)
    puts "Executive summary saved to: #{summary_file}"
  end
end

# === Workflow Step Functions ===

def ensure_required_subfolders(target_dir:)
  MeetingFileUtils.ensure_subfolders(target_dir: target_dir)
end

def select_meeting_folder(transcripts_meeting_dir:)
  select_folder_script = File.join(File.dirname(__FILE__), "select-folder")
  selected_folder = `"#{select_folder_script}" --target-dir "#{transcripts_meeting_dir}"`.strip
  if selected_folder.empty?
    puts "No folder selected. Exiting."
    exit 1
  end
  puts "Selected meeting folder: #{selected_folder}"
  selected_folder
end

def find_transcript_files(selected_folder:)
  transcript_files = MeetingFileUtils.find_transcript_files(folder: selected_folder)
  if transcript_files.empty?
    puts "No transcript or chat log files found in #{selected_folder}. Exiting."
    exit 1
  end
  transcript_files
end

def prepare_transcript_output(selected_folder:, target_dir:)
  meeting_date = File.mtime(selected_folder).strftime("%Y-%m-%d")
  transcripts_base = File.join(target_dir, "Transcripts")
  dest_dir = MeetingFileUtils.prepare_transcript_dir(transcripts_base: transcripts_base, meeting_date: meeting_date)
  filename = MeetingFileUtils.next_transcript_filename(dest_dir: dest_dir)
  dest_file = File.join(dest_dir, filename)
  [meeting_date, dest_file, filename, dest_dir]
end

def write_combined_transcript(dest_file:, transcript_files:)
  MeetingFileUtils.write_combined_transcript(dest_file: dest_file, transcript_files: transcript_files)
  puts "Transcript and chat log saved to: #{dest_file}"
end

def generate_executive_summary(dest_file:, target_dir:, meeting_date:, filename:, llm_model:, executive_summary_prompt_path:)
  exec_summaries_base = File.join(target_dir, "Executive Summaries")
  exec_dir = File.join(exec_summaries_base, meeting_date)
  FileUtils.mkdir_p(exec_dir)
  summary_file = File.join(exec_dir, filename)
  LlmWorkflowUtils.generate_executive_summary(dest_file: dest_file, summary_file: summary_file, llm_model: llm_model, prompt_path: executive_summary_prompt_path)
  summary_file
end

def find_latest_weekly_notes(target_dir:)
  weekly_notes_dir = File.join(target_dir, "Weekly Notes")
  weekly_notes_files = Dir[File.join(weekly_notes_dir, "Week of *.md")].sort
  if weekly_notes_files.empty?
    puts "No weekly notes files found in #{weekly_notes_dir}."
    exit 1
  end
  latest_weekly_notes = weekly_notes_files.last
  puts "Latest weekly notes file: #{latest_weekly_notes}"
  latest_weekly_notes
end

def select_meeting_notes_section(latest_weekly_notes:, summary_file:, llm_model:)
  weekly_notes_content = File.read(latest_weekly_notes)
  executive_summary_content = File.read(summary_file)
  LlmWorkflowUtils.select_meeting_notes_section(
    weekly_notes_content: weekly_notes_content,
    executive_summary_content: executive_summary_content,
    llm_model: llm_model
  )
end

def update_meeting_notes(target_dir:, selection:, meeting_date:, filename:)
  meeting_notes_file = File.join(target_dir, "Meeting Notes", "#{selection}.md")
  wikilink_name = File.basename(filename, ".md")
  transcript_link = "[[Transcripts/#{meeting_date}/#{wikilink_name}|Transcript]]"
  summary_link = "[[Executive Summaries/#{meeting_date}/#{wikilink_name}|Executive Summary]]"
  MeetingFileUtils.update_meeting_notes_file(
    meeting_notes_file: meeting_notes_file,
    meeting_date: meeting_date,
    transcript_link: transcript_link,
    summary_link: summary_link,
    filename: filename
  )
end

# === Main Workflow ===

options = {
  transcripts_dir: nil,
  target_dir: nil,
  llm_model: nil,
  executive_summary_prompt_path: nil,
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} --transcripts-dir DIR --target-dir DIR --executive-summary-prompt-path PATH [--llm-model MODEL]"
  opts.on("--transcripts-dir DIR", "Path to Zoom meetings folder") { |dir| options[:transcripts_dir] = dir }
  opts.on("--target-dir DIR", "Path to notes folder") { |dir| options[:target_dir] = dir }
  opts.on("--executive-summary-prompt-path PATH", "Path to LLM prompt file") { |path| options[:executive_summary_prompt_path] = path }
  opts.on("--llm-model MODEL", "Model alias to use for llm -m (default: nil)") { |model| options[:llm_model] = model }
  opts.on("-h", "--help", "Show this help message") { puts opts; exit }
end

begin
  opt_parser.parse!
rescue OptionParser::InvalidOption => e
  puts e
  puts opt_parser
  exit 1
end

if options[:transcripts_dir].nil? || options[:target_dir].nil?
  puts opt_parser
  exit 1
end

if options[:executive_summary_prompt_path].nil?
  puts "--llm-prompt-path is required."
  puts opt_parser
  exit 1
end

# Step 1: Ensure required subfolders exist
ensure_required_subfolders(target_dir: options[:target_dir])

# Step 2: Select meeting folder
selected_folder = select_meeting_folder(transcripts_meeting_dir: options[:transcripts_dir])

# Step 3: Find transcript and chat log files
transcript_files = find_transcript_files(selected_folder: selected_folder)

# Step 4: Prepare output directory and file for transcript
meeting_date, dest_file, filename, _dest_dir = prepare_transcript_output(selected_folder: selected_folder, target_dir: options[:target_dir])

# Step 5: Write combined transcript and chat log file
write_combined_transcript(dest_file: dest_file, transcript_files: transcript_files)

# Step 6: Generate executive summary using llm
summary_file = generate_executive_summary(
  dest_file: dest_file,
  target_dir: options[:target_dir],
  meeting_date: meeting_date,
  filename: filename,
  llm_model: options[:llm_model],
  executive_summary_prompt_path: options[:executive_summary_prompt_path]
)

# Step 7: Find latest Weekly Notes file
latest_weekly_notes = find_latest_weekly_notes(target_dir: options[:target_dir])

# Step 8: Use LLM and fzf to select Meeting Notes group/person/section
selection = select_meeting_notes_section(
  latest_weekly_notes: latest_weekly_notes,
  summary_file: summary_file,
  llm_model: options[:llm_model]
)

# Step 9: Update Meeting Notes file
update_meeting_notes(
  target_dir: options[:target_dir],
  selection: selection,
  meeting_date: meeting_date,
  filename: filename
)
