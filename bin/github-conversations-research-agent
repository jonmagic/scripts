#!/usr/bin/env ruby

# bin/github-conversations-research-agent: Multi-turn research agent for GitHub conversations
#
# This script implements a research workflow that:
# 1. Takes a natural language request and performs initial semantic search
# 2. Generates clarifying questions and opens them in $EDITOR
# 3. Performs iterative deep research based on clarifications
# 4. Produces a final well-formatted Markdown report citing all sources
#
# Usage: github-conversations-research-agent "REQUEST" --collection COLLECTION [options]
#
# Options:
#   --collection NAME       Qdrant collection name (required)
#   --limit N               Max results per search (default: 5)
#   --max-depth N           Max deep-research passes (default: 2)
#   --editor-file PATH      Use fixed file instead of Tempfile
#   --clarifying-qa PATH    Path to file with clarifying Q&A to bypass interactive step
#   --verbose               Show debug logs
#   --fast-model MODEL      Fast LLM model for light reasoning
#   --reasoning-model MODEL Reasoning LLM model for complex analysis
#   --search-mode MODE      Override search mode (semantic, keyword, or hybrid - default: hybrid)
#   --cache-path PATH       Root path for caching fetched data
#
# The script uses the existing bin/semantic-search-github-conversations,
# bin/search-github-conversations and bin/fetch-github-conversation scripts
# to gather context, and integrates with the llm CLI for AI-powered analysis.

require "json"
require "logger"
require "open3"
require "optparse"
require "tempfile"
require "shellwords"

# Load vendored Pocketflow library
require_relative "../lib/pocketflow"

# Load GitHub Deep Research Agent modules
require_relative "../lib/utils"
require_relative "../lib/github_deep_research_agent/end_node"
require_relative "../lib/github_deep_research_agent/final_report_node"
require_relative "../lib/github_deep_research_agent/claim_verifier_node"
require_relative "../lib/github_deep_research_agent/context_compaction_node"
require_relative "../lib/github_deep_research_agent/retriever_node"
require_relative "../lib/github_deep_research_agent/planner_node"
require_relative "../lib/github_deep_research_agent/ask_clarifying_node"
require_relative "../lib/github_deep_research_agent/initial_research_node"

# Set up global logger
LOG = Logger.new($stdout)
LOG.level = Logger::INFO  # Default level, will be changed to DEBUG with --verbose

# === Main Script ===

# Parse command-line options
options = {
  collection: nil,
  limit: 5,
  max_depth: 2,
  editor_file: nil,
  clarifying_qa: nil,
  verbose: false,
  fast_model: ENV["FAST_LLM_MODEL"],
  reasoning_model: ENV["LLM_MODEL"],
  search_mode: "hybrid",
  cache_path: nil
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($0)} \"REQUEST\" --collection COLLECTION [options]"

  opts.on("--collection NAME", "Qdrant collection name (required)") do |v|
    options[:collection] = v
  end

  opts.on("--limit N", Integer, "Max results per search (default: 5)") do |v|
    options[:limit] = v
  end

  opts.on("--max-depth N", Integer, "Max deep-research passes (default: 2)") do |v|
    options[:max_depth] = v
  end

  opts.on("--editor-file PATH", "Use fixed file instead of Tempfile") do |v|
    options[:editor_file] = v
  end

  opts.on("--clarifying-qa PATH", "Path to file with clarifying Q&A to bypass interactive step") do |v|
    options[:clarifying_qa] = v
  end

  opts.on("--verbose", "Show debug logs") do
    options[:verbose] = true
  end

  opts.on("--fast-model MODEL", "Fast LLM model for light reasoning (default: ENV['FAST_LLM_MODEL'] or llm default)") do |v|
    options[:fast_model] = v
  end

  opts.on("--reasoning-model MODEL", "Reasoning LLM model for complex analysis (default: ENV['LLM_MODEL'] or llm default)") do |v|
    options[:reasoning_model] = v
  end

  opts.on("--search-mode MODE", ["semantic", "keyword", "hybrid"], "Override search mode (semantic, keyword, or hybrid - default: hybrid)") do |v|
    options[:search_mode] = v
  end

  opts.on("--cache-path PATH", "Root path for caching fetched data") do |v|
    options[:cache_path] = v
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

begin
  opt_parser.parse!
rescue OptionParser::InvalidOption => e
  abort "#{e.message}\n\n#{opt_parser}"
end

# Set logger level based on verbose flag
LOG.level = options[:verbose] ? Logger::DEBUG : Logger::INFO

# Validate required arguments
if ARGV.empty?
  abort opt_parser.to_s
end

request = ARGV.join(" ")

if request.strip.empty?
  abort "Error: Empty request provided"
end

unless options[:collection]
  abort "Error: --collection is required\n\n#{opt_parser}"
end

# Set up shared context
script_dir = File.expand_path(File.dirname(__FILE__))

shared = {
  request: request,
  collection: options[:collection],
  top_k: options[:limit],
  max_depth: options[:max_depth],
  editor_file: options[:editor_file],
  clarifying_qa: options[:clarifying_qa],
  verbose: options[:verbose],
  search_mode: options[:search_mode],
  cache_path: options[:cache_path],
  models: {
    fast: options[:fast_model],
    reasoning: options[:reasoning_model]
  },
  script_dir: script_dir
}

# Build the workflow
initial_node = GitHubDeepResearchAgent::InitialResearchNode.new
clarify_node = GitHubDeepResearchAgent::AskClarifyingNode.new
planner_node = GitHubDeepResearchAgent::PlannerNode.new
retriever_node = GitHubDeepResearchAgent::RetrieverNode.new
compaction_node = GitHubDeepResearchAgent::ContextCompactionNode.new
claim_verifier_node = GitHubDeepResearchAgent::ClaimVerifierNode.new
final_node = GitHubDeepResearchAgent::FinalReportNode.new
end_node = GitHubDeepResearchAgent::EndNode.new

# Link the nodes
initial_node.next(clarify_node)
clarify_node.next(planner_node)
planner_node.next(retriever_node)
retriever_node.on("continue", planner_node) # Loop back to planner for next iteration
retriever_node.on("final", final_node)

# Add claim verification flow
final_node.on("verify", claim_verifier_node)  # Route to claim verification after draft report
final_node.on("complete", end_node)           # Route to clean termination
claim_verifier_node.on("ok", final_node)     # Continue to final output after verification
claim_verifier_node.on("fix", planner_node)  # Route back to planner to gather evidence for unsupported claims

# Add compaction handling
final_node.on("compact", compaction_node)         # Route to compaction when context too large
compaction_node.on("retry", final_node)          # Retry final report after compaction
compaction_node.on("proceed_anyway", final_node) # Proceed with minimal context if compaction fails

# Set end node as the final termination point
final_node.next(end_node)

# Create and run the flow
flow = Pocketflow::Flow.new(initial_node)

begin
  LOG.info "=== GITHUB CONVERSATIONS RESEARCH AGENT ==="
  LOG.info "Request: #{request}"
  LOG.info "Collection: #{options[:collection]}"
  LOG.info "Max results per search: #{options[:limit]}"
  LOG.info "Max deep research iterations: #{options[:max_depth]}"
  LOG.info "Fast model: #{shared[:models][:fast] || 'default'}"
  LOG.info "Reasoning model: #{shared[:models][:reasoning] || 'default'}"

  flow.run(shared)
rescue Interrupt
  LOG.error "\nResearch interrupted by user"
  exit 1
rescue => e
  LOG.error "Error: #{e.message}"
  LOG.debug e.backtrace.join("\n") if shared[:verbose]
  exit 1
end
