#!/usr/bin/env ruby

# index-summary: Generate embeddings from GitHub conversation summaries and index them in a Qdrant collection.
#
# Usage:
#   index-summary <github_conversation_url> --executive-summary-prompt-path <prompt_path> --topics-prompt-path <prompt_path> [options]
#
# This script uses the existing fetch-github-conversation, summarize-github-conversation, and extract-topics
# commands to get conversation data, generates embeddings using the llm CLI, and indexes them in Qdrant
# with comprehensive metadata for semantic search.
#
# Requirements:
# - Ruby
# - fetch-github-conversation, summarize-github-conversation, and extract-topics scripts in PATH
# - llm CLI in PATH with embedding support
# - Qdrant server accessible for indexing

require "fileutils"
require "json"
require "open3"
require "optparse"
require "shellwords"
require "net/http"
require "uri"
require "time"

# Run a shell command and return stdout, abort on failure.
def run_cmd(cmd)
  stdout, stderr, status = Open3.capture3(cmd)
  abort "Command failed: #{cmd}\n#{stderr}" unless status.success?
  stdout
end

# Parse a GitHub conversation URL or <owner>/<repo>/<type>/<number>.
def parse_input(input)
  if input =~ %r{^https://github.com/}
    m = input.match(%r{github.com/([^/]+)/([^/]+)/(issues|pull|discussions)/([0-9]+)})
    abort "Unrecognized GitHub conversation URL: #{input}" unless m
    [m[1], m[2], m[3], m[4]]
  elsif input =~ %r{^([^/]+)/([^/]+)/(issues|pull|discussions)/([0-9]+)$}
    m = input.match(%r{^([^/]+)/([^/]+)/(issues|pull|discussions)/([0-9]+)$})
    [m[1], m[2], m[3], m[4]]
  else
    abort "Input must be a GitHub URL or <owner>/<repo>/<type>/<number>"
  end
end

# Format the conversation type for output
def format_type(type)
  case type
  when "issues"
    "issue"
  when "pull"
    "pr"
  when "discussions"
    "discussion"
  else
    abort "Unrecognized conversation type: #{type}"
  end
end

# Extract metadata from conversation data for Qdrant indexing
def extract_metadata(data, type, topics)
  conversation_key = {
    "pull" => "pr",
    "issues" => "issue", 
    "discussions" => "discussion"
  }[type]
  
  conversation = data[conversation_key]
  return {} unless conversation
  
  {
    url: conversation["html_url"] || conversation["url"],
    created_at: conversation["created_at"],
    updated_at: conversation["updated_at"],
    closed_at: conversation["closed_at"],
    state: conversation["state"],
    author: conversation["author"],
    topics: topics
  }.compact
end

# Generate embedding for the summary text using llm embed
def generate_embedding(summary_text, model = "text-embedding-3-small")
  cmd = ["llm", "embed", "-m", model]
  
  stdout, stderr, status = Open3.capture3(*cmd, stdin_data: summary_text)
  unless status.success?
    abort "Command failed: #{cmd.join(' ')}\n#{stderr}"
  end
  
  # Parse the embedding output (expecting JSON format)
  begin
    JSON.parse(stdout)
  rescue JSON::ParserError
    abort "Failed to parse embedding output as JSON: #{stdout.strip}"
  end
end

# Index the embedding in Qdrant collection
def index_in_qdrant(embedding, metadata, summary_text, options)
  qdrant_url = options[:qdrant_url]
  collection_name = options[:collection_name]
  
  # Generate a unique ID for this embedding based on the conversation
  point_id = "#{metadata[:url].gsub(/[^a-zA-Z0-9]/, '_')}"
  
  # Prepare the payload for Qdrant including the summary text
  payload = {
    id: point_id,
    vector: embedding,
    payload: metadata.merge(
      summary: summary_text,
      indexed_at: Time.now.utc.iso8601
    )
  }
  
  # Make HTTP request to Qdrant
  uri = URI("#{qdrant_url}/collections/#{collection_name}/points")
  
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true if uri.scheme == 'https'
  
  request = Net::HTTP::Put.new(uri)
  request['Content-Type'] = 'application/json'
  request.body = {
    points: [payload]
  }.to_json
  
  response = http.request(request)
  
  unless response.code.to_i.between?(200, 299)
    abort "Failed to index in Qdrant: #{response.code} #{response.body}"
  end
  
  puts "Successfully indexed embedding for #{point_id}"
  response
end

# CLI options
options = {
  executive_summary_prompt_path: nil,
  topics_prompt_path: nil,
  cache_path: nil,
  updated_at: nil,
  qdrant_url: "http://localhost:6333",
  collection_name: "summaries",
  model: "text-embedding-3-small"
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} <github_conversation_url> --executive-summary-prompt-path <prompt_path> --topics-prompt-path <prompt_path> [options]"
  opts.on("--executive-summary-prompt-path PATH", "Path to LLM prompt file for summary generation (required)") { |v| options[:executive_summary_prompt_path] = v }
  opts.on("--topics-prompt-path PATH", "Path to LLM prompt file for topic extraction (required)") { |v| options[:topics_prompt_path] = v }
  opts.on("--cache-path PATH", "Root path for caching fetched data") { |v| options[:cache_path] = v }
  opts.on("--updated-at TIME", "Timestamp to compare against (ISO8601)") { |v| options[:updated_at] = v }
  opts.on("--qdrant-url URL", "Qdrant server URL (default: http://localhost:6333)") { |v| options[:qdrant_url] = v }
  opts.on("--collection-name NAME", "Qdrant collection name (default: summaries)") { |v| options[:collection_name] = v }
  opts.on("--model MODEL", "Embedding model to use (default: text-embedding-3-small)") { |v| options[:model] = v }
  opts.on("-h", "--help", "Show this help message") { puts opts; exit }
end
opt_parser.parse!
opt_parser.order!(ARGV)

# Validate required options
if options[:executive_summary_prompt_path].nil?
  puts "--executive-summary-prompt-path is required."
  puts opt_parser
  exit 1
end

if options[:topics_prompt_path].nil?
  puts "--topics-prompt-path is required."
  puts opt_parser
  exit 1
end

input = ARGV[0]
abort opt_parser.to_s unless input
ARGV.delete(input)

# Parse the GitHub URL to extract metadata
owner, repo, type, number = parse_input(input)

# Find the directory of this script to locate other scripts
script_dir = File.expand_path(File.dirname(__FILE__))
fetch_script = File.join(script_dir, "fetch-github-conversation")
summarize_script = File.join(script_dir, "summarize-github-conversation")
topics_script = File.join(script_dir, "extract-topics")

# Build fetch-github-conversation command
fetch_cmd = [fetch_script, input]
fetch_cmd << "--cache-path" << options[:cache_path] if options[:cache_path]
fetch_cmd << "--updated-at" << options[:updated_at] if options[:updated_at]

# Build summarize-github-conversation command
summarize_cmd = [summarize_script, input, "--executive-summary-prompt-path", options[:executive_summary_prompt_path]]
summarize_cmd << "--cache-path" << options[:cache_path] if options[:cache_path]
summarize_cmd << "--updated-at" << options[:updated_at] if options[:updated_at]

# Build extract-topics command  
topics_cmd = [topics_script, input, "--topics-prompt-path", options[:topics_prompt_path]]
topics_cmd << "--cache-path" << options[:cache_path] if options[:cache_path]
topics_cmd << "--updated-at" << options[:updated_at] if options[:updated_at]

puts "Fetching GitHub conversation #{owner}/#{repo}/#{format_type(type)}/#{number}..."

# Fetch conversation data
conversation_json = run_cmd(fetch_cmd.shelljoin)
data = JSON.parse(conversation_json)

puts "Generating summary..."

# Generate summary
summary_text = run_cmd(summarize_cmd.shelljoin).strip

if summary_text.empty?
  abort "Generated summary is empty"
end

puts "Extracting topics..."

# Extract topics
topics_output = run_cmd(topics_cmd.shelljoin).strip
topics = topics_output.empty? ? [] : topics_output.split(/[,\n]/).map(&:strip).reject(&:empty?)

puts "Extracting metadata..."

# Extract metadata from conversation data
metadata = extract_metadata(data, type, topics)

puts "Generating embedding for summary (#{summary_text.length} characters)..."

# Generate embedding
embedding = generate_embedding(summary_text, options[:model])

puts "Embedding generated with #{embedding.length} dimensions"

# Index in Qdrant
puts "Indexing in Qdrant collection '#{options[:collection_name]}'..."
index_in_qdrant(embedding, metadata, summary_text, options)

puts "Summary successfully indexed!"