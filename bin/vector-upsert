#!/usr/bin/env ruby

# vector-upsert: Generic tool for embedding text and upserting vectors with metadata into Qdrant collections
#
# Usage:
#   echo "text to embed" | vector-upsert --collection COLLECTION --metadata '{"url": "...", "key": "value"}' --text-key summary [options]
#
# This script takes arbitrary text via stdin, generates embeddings using the llm CLI, and upserts the resulting
# vector along with flat JSON metadata into a specified Qdrant collection. The collection will be created if it doesn't exist.
#
# Requirements:
# - Ruby
# - llm CLI in PATH with embedding model support
# - curl for Qdrant HTTP API calls
# - Qdrant server running and accessible

require "digest"
require "json"
require "open3"
require "optparse"
require "shellwords"
require "uri"
require "net/http"

# Run a shell command and return stdout, abort on failure.
def run_cmd(cmd)
  stdout, stderr, status = Open3.capture3(cmd)
  abort "Command failed: #{cmd}\n#{stderr}" unless status.success?
  stdout
end

# Check if a required command-line dependency is available in PATH.
def check_dependency(cmd)
  system("which #{cmd} > /dev/null 2>&1") || abort("Required dependency '#{cmd}' not found in PATH.")
end

# Validate that a JSON object is flat (no nested objects or arrays)
def validate_flat_json(obj, path = "")
  case obj
  when Hash
    obj.each do |key, value|
      current_path = path.empty? ? key : "#{path}.#{key}"
      if value.is_a?(Hash) || value.is_a?(Array)
        abort "Metadata must be flat JSON. Found nested structure at: #{current_path}"
      end
    end
  when Array
    abort "Metadata must be a flat JSON object, not an array"
  else
    abort "Metadata must be a JSON object"
  end
end

# Generate a stable ID for the vector based on key content
def generate_vector_id(metadata, text_key, text_content)
  # Try to use the value of the specified text key for ID generation
  if metadata[text_key]
    content_for_id = metadata[text_key]
  else
    # Fall back to the actual text content
    content_for_id = text_content
  end
  
  # Use SHA-256 to generate a stable, reproducible ID
  Digest::SHA256.hexdigest(content_for_id.to_s)
end

# Generate embedding using llm CLI
def generate_embedding(text, model)
  cmd = "llm embed -c #{Shellwords.escape(text)}"
  
  # If no model specified, try to use a reasonable default
  if model.nil? || model.empty?
    # Try text-embedding-3-small first, then text-embedding-ada-002 as fallback
    model = "text-embedding-3-small"
    cmd += " -m #{Shellwords.escape(model)}"
  else
    cmd += " -m #{Shellwords.escape(model)}"
  end
  
  cmd += " -f json"
  
  embedding_json = run_cmd(cmd)
  JSON.parse(embedding_json)
rescue JSON::ParserError => e
  abort "Failed to parse embedding JSON: #{e.message}"
end

# Create Qdrant collection if it doesn't exist
def ensure_collection_exists(qdrant_url, collection_name, vector_size)
  uri = URI("#{qdrant_url}/collections/#{collection_name}")
  
  # First, check if collection exists
  response = Net::HTTP.get_response(uri)
  return if response.code == "200"
  
  # Collection doesn't exist, create it
  create_uri = URI("#{qdrant_url}/collections/#{collection_name}")
  http = Net::HTTP.new(create_uri.host, create_uri.port)
  
  create_request = Net::HTTP::Put.new(create_uri)
  create_request["Content-Type"] = "application/json"
  create_request.body = {
    vectors: {
      distance: "Cosine",
      size: vector_size
    }
  }.to_json
  
  create_response = http.request(create_request)
  unless create_response.code.to_i.between?(200, 299)
    abort "Failed to create Qdrant collection '#{collection_name}': #{create_response.code} #{create_response.body}"
  end
end

# Upsert vector and metadata to Qdrant
def upsert_to_qdrant(qdrant_url, collection_name, vector_id, embedding, metadata)
  uri = URI("#{qdrant_url}/collections/#{collection_name}/points")
  http = Net::HTTP.new(uri.host, uri.port)
  
  request = Net::HTTP::Put.new(uri)
  request["Content-Type"] = "application/json"
  request.body = {
    points: [{
      id: vector_id,
      vector: embedding,
      payload: metadata
    }]
  }.to_json
  
  response = http.request(request)
  unless response.code.to_i.between?(200, 299)
    abort "Failed to upsert to Qdrant collection '#{collection_name}': #{response.code} #{response.body}"
  end
  
  response
end

# === Main Script ===

# Check dependencies
check_dependency("llm")
check_dependency("curl")

# Parse command-line options
options = {}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} --collection COLLECTION --metadata JSON [options] < text_file"
  opts.on("--collection COLLECTION", "Qdrant collection name (required)") { |v| options[:collection] = v }
  opts.on("--metadata JSON", "Flat JSON metadata object (required)") { |v| options[:metadata] = v }
  opts.on("--text-key KEY", "Key in metadata that contains the main text for ID generation (default: use stdin content)") { |v| options[:text_key] = v }
  opts.on("--model MODEL", "Embedding model to use (default: let llm CLI decide)") { |v| options[:model] = v }
  opts.on("--qdrant-url URL", "Qdrant server URL (default: http://localhost:6333)") { |v| options[:qdrant_url] = v }
  opts.on("-h", "--help", "Show this help message") { puts opts; exit }
end

begin
  opt_parser.parse!
rescue OptionParser::InvalidOption => e
  abort "#{e.message}\n\n#{opt_parser}"
end

# Validate required arguments
if options[:collection].nil? || options[:collection].strip.empty?
  abort "Error: --collection is required\n\n#{opt_parser}"
end

if options[:metadata].nil? || options[:metadata].strip.empty?
  abort "Error: --metadata is required\n\n#{opt_parser}"
end

# Set defaults
options[:qdrant_url] ||= "http://localhost:6333"
options[:text_key] ||= nil

# Parse and validate metadata JSON
begin
  metadata = JSON.parse(options[:metadata])
rescue JSON::ParserError => e
  abort "Error: Invalid JSON in --metadata: #{e.message}"
end

validate_flat_json(metadata)

# Read text from stdin
if STDIN.tty?
  abort "Error: No text provided via stdin. Please pipe text to this script."
end

text_content = STDIN.read.strip
if text_content.empty?
  abort "Error: Empty text content provided via stdin."
end

# Generate embedding
puts "Generating embedding..."
embedding = generate_embedding(text_content, options[:model])

# Generate stable vector ID
vector_id = generate_vector_id(metadata, options[:text_key], text_content)

# Ensure collection exists
puts "Ensuring Qdrant collection '#{options[:collection]}' exists..."
ensure_collection_exists(options[:qdrant_url], options[:collection], embedding.length)

# Upsert to Qdrant
puts "Upserting vector to Qdrant..."
response = upsert_to_qdrant(options[:qdrant_url], options[:collection], vector_id, embedding, metadata)

puts "Successfully upserted vector with ID: #{vector_id}"
puts "Collection: #{options[:collection]}"
puts "Vector dimensions: #{embedding.length}"
puts "Metadata keys: #{metadata.keys.join(', ')}"